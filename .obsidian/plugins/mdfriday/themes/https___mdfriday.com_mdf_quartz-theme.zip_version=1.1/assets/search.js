// Search functionality - Based on Quartz search.inline.ts
// Uses FlexSearch for fast, client-side full-text search

{{/* Generate search data file path */}}
{{ $searchDataFile := printf "%s.search-data.json" .Language.Lang }}
{{ $searchData := resources.Get "search-data.json" | resources.ExecuteAsTemplate $searchDataFile . | resources.Minify | resources.Fingerprint }}

(function() {
  console.log('[Search] Initializing search functionality');

  // Search data URL (generated by Hugo template)
  const searchDataURL = '{{ $searchData.RelPermalink }}';

  // CJK-aware tokenizer (from Quartz)
  const encoder = (str) => {
    const tokens = [];
    let bufferStart = -1;
    let bufferEnd = -1;
    const lower = str.toLowerCase();

    let i = 0;
    for (const char of lower) {
      const code = char.codePointAt(0);

      const isCJK =
        (code >= 0x3040 && code <= 0x309f) ||
        (code >= 0x30a0 && code <= 0x30ff) ||
        (code >= 0x4e00 && code <= 0x9fff) ||
        (code >= 0xac00 && code <= 0xd7af) ||
        (code >= 0x20000 && code <= 0x2a6df);

      const isWhitespace = code === 32 || code === 9 || code === 10 || code === 13;

      if (isCJK) {
        if (bufferStart !== -1) {
          tokens.push(lower.slice(bufferStart, bufferEnd));
          bufferStart = -1;
        }
        tokens.push(char);
      } else if (isWhitespace) {
        if (bufferStart !== -1) {
          tokens.push(lower.slice(bufferStart, bufferEnd));
          bufferStart = -1;
        }
      } else {
        if (bufferStart === -1) bufferStart = i;
        bufferEnd = i + char.length;
      }

      i += char.length;
    }

    if (bufferStart !== -1) {
      tokens.push(lower.slice(bufferStart));
    }

    return tokens;
  };

  // Initialize FlexSearch index
  let index = null;
  let indexPopulated = false;
  let searchData = null;
  const contextWindowWords = 30;
  const numSearchResults = 8;

  // Tokenize search term for highlighting
  const tokenizeTerm = (term) => {
    const tokens = term.split(/\s+/).filter((t) => t.trim() !== '');
    const tokenLen = tokens.length;
    if (tokenLen > 1) {
      for (let i = 1; i < tokenLen; i++) {
        tokens.push(tokens.slice(0, i + 1).join(' '));
      }
    }
    return tokens.sort((a, b) => b.length - a.length); // longest first
  };

  // Highlight search term in text
  function highlight(searchTerm, text, trim = false) {
    const tokenizedTerms = tokenizeTerm(searchTerm);
    let tokenizedText = text.split(/\s+/).filter((t) => t !== '');

    let startIndex = 0;
    let endIndex = tokenizedText.length - 1;

    if (trim) {
      const includesCheck = (tok) =>
        tokenizedTerms.some((term) => tok.toLowerCase().startsWith(term.toLowerCase()));
      const occurrencesIndices = tokenizedText.map(includesCheck);

      let bestSum = 0;
      let bestIndex = 0;
      for (let i = 0; i < Math.max(tokenizedText.length - contextWindowWords, 0); i++) {
        const window = occurrencesIndices.slice(i, i + contextWindowWords);
        const windowSum = window.reduce((total, cur) => total + (cur ? 1 : 0), 0);
        if (windowSum >= bestSum) {
          bestSum = windowSum;
          bestIndex = i;
        }
      }

      startIndex = Math.max(bestIndex - contextWindowWords, 0);
      endIndex = Math.min(startIndex + 2 * contextWindowWords, tokenizedText.length - 1);
      tokenizedText = tokenizedText.slice(startIndex, endIndex);
    }

    const slice = tokenizedText
      .map((tok) => {
        for (const searchTok of tokenizedTerms) {
          if (tok.toLowerCase().includes(searchTok.toLowerCase())) {
            const regex = new RegExp(searchTok.toLowerCase(), 'gi');
            return tok.replace(regex, `<span class="highlight">$&</span>`);
          }
        }
        return tok;
      })
      .join(' ');

    return `${startIndex === 0 ? '' : '...'}${slice}${
      endIndex === tokenizedText.length - 1 ? '' : '...'
    }`;
  }

  // Highlight HTML content (for preview)
  function highlightHTML(searchTerm, el) {
    const tokenizedTerms = tokenizeTerm(searchTerm);
    const nodeQueue = [el];

    while (nodeQueue.length > 0) {
      const currentNode = nodeQueue.shift();
      const nodeType = currentNode.nodeType;

      if (nodeType === Node.TEXT_NODE) {
        let text = currentNode.textContent;
        let parent = currentNode.parentElement;

        for (const term of tokenizedTerms) {
          const regex = new RegExp(term.toLowerCase(), 'gi');
          if (regex.test(text)) {
            const span = document.createElement('span');
            span.innerHTML = text.replace(regex, '<span class="highlight">$&</span>');
            parent.replaceChild(span, currentNode);
            break;
          }
        }
      } else if (nodeType === Node.ELEMENT_NODE) {
        nodeQueue.push(...currentNode.childNodes);
      }
    }

    return el;
  }

  // Helper to remove all children from element
  function removeAllChildren(el) {
    while (el.firstChild) {
      el.removeChild(el.firstChild);
    }
  }

  // Setup search for each search element
  async function setupSearch(searchElement) {
    console.log('[Search] Setting up search element');

    const container = searchElement.querySelector('.search-container');
    if (!container) {
      console.warn('[Search] No search container found');
      return;
    }

    const sidebar = container.closest('.sidebar');
    const searchButton = searchElement.querySelector('.search-button');
    const searchBar = searchElement.querySelector('.search-bar');
    const searchLayout = searchElement.querySelector('.search-layout');

    if (!searchButton || !searchBar || !searchLayout) {
      console.warn('[Search] Missing required search elements');
      return;
    }

    // Create results container
    const results = document.createElement('div');
    results.className = 'results-container';
    searchLayout.appendChild(results);

    // Create preview container if enabled
    const enablePreview = searchLayout.dataset.preview === 'true';
    let preview = undefined;
    let previewInner = undefined;
    let currentHover = null;
    let currentSearchTerm = '';
    const fetchContentCache = new Map();
    const p = new DOMParser();

    if (enablePreview) {
      preview = document.createElement('div');
      preview.className = 'preview-container';
      searchLayout.appendChild(preview);
    }

    function hideSearch() {
      container.classList.remove('active');
      searchBar.value = '';
      if (sidebar) sidebar.style.zIndex = '';
      removeAllChildren(results);
      if (preview) {
        removeAllChildren(preview);
      }
      searchLayout.classList.remove('display-results');
      currentSearchTerm = '';
      searchButton.focus();
    }

    function showSearch() {
      if (sidebar) sidebar.style.zIndex = '1';
      container.classList.add('active');
      searchBar.focus();
    }

    // Fetch page content for preview
    async function fetchContent(slug) {
      if (fetchContentCache.has(slug)) {
        return fetchContentCache.get(slug);
      }

      const data = searchData[slug];
      const targetUrl = data ? data.url : `/${slug}.html`;
      
      try {
        const response = await fetch(targetUrl);
        const contents = await response.text();
        
        if (!contents) {
          throw new Error(`Could not fetch ${targetUrl}`);
        }
        
        const html = p.parseFromString(contents, 'text/html');
        const popoverHints = [...html.getElementsByClassName('popover-hint')];
        
        fetchContentCache.set(slug, popoverHints);
        return popoverHints;
      } catch (error) {
        console.error(`[Search] Failed to fetch content for ${slug}:`, error);
        return [];
      }
    }

    // Display preview for a result card
    async function displayPreview(el) {
      if (!searchLayout || !enablePreview || !el || !preview) return;
      
      const slug = el.id;
      const innerDiv = await fetchContent(slug).then((contents) =>
        contents.flatMap((el) => [...highlightHTML(currentSearchTerm, el.cloneNode(true)).children]),
      );
      
      previewInner = document.createElement('div');
      previewInner.classList.add('preview-inner');
      previewInner.append(...innerDiv);
      preview.replaceChildren(previewInner);

      // Scroll to longest highlight
      const highlights = [...preview.getElementsByClassName('highlight')].sort(
        (a, b) => b.innerHTML.length - a.innerHTML.length,
      );
      highlights[0]?.scrollIntoView({ block: 'start' });
    }

    // Load search data and build index
    async function loadSearchIndex() {
      if (indexPopulated) return;

      console.log('[Search] Loading search data from:', searchDataURL);
      
      try {
        const response = await fetch(searchDataURL);
        searchData = await response.json();
        
        console.log(`[Search] Loaded ${Object.keys(searchData).length} pages`);

        // Initialize FlexSearch index
        index = new FlexSearch.Document({
          encode: encoder,
          document: {
            id: 'id',
            tag: 'tags',
            index: [
              {
                field: 'title',
                tokenize: 'forward',
              },
              {
                field: 'content',
                tokenize: 'forward',
              },
              {
                field: 'tags',
                tokenize: 'forward',
              },
            ],
          },
        });

        // Add documents to index
        const slugs = Object.keys(searchData);
        const promises = [];
        slugs.forEach((slug, id) => {
          const data = searchData[slug];
          promises.push(
            index.addAsync(id, {
              id: id,
              slug: slug,
              title: data.title,
              content: data.content,
              tags: data.tags || [],
            })
          );
        });

        await Promise.all(promises);
        indexPopulated = true;
        console.log('[Search] Index built successfully');
      } catch (error) {
        console.error('[Search] Failed to load search data:', error);
      }
    }

    // Format results for display
    function formatResult(term, id) {
      const slugs = Object.keys(searchData);
      const slug = slugs[id];
      const data = searchData[slug];

      return {
        id,
        slug,
        title: highlight(term, data.title || ''),
        content: highlight(term, data.content || '', true),
        tags: data.tags || [],
      };
    }

    // Create HTML for result card
    function resultToHTML({ slug, title, content, tags }) {
      // Get URL from search data (already includes baseURL from RelPermalink)
      const data = searchData[slug];
      const url = data ? data.url : `/${slug}.html`;

      const htmlTags = tags.length > 0
        ? `<ul class="tags">${tags.map(tag => `<li><p>#${tag}</p></li>`).join('')}</ul>`
        : '';

      const card = document.createElement('a');
      card.classList.add('result-card');
      card.id = slug;
      card.href = url;
      card.innerHTML = `
        <h3 class="card-title">${title}</h3>
        ${htmlTags}
        <p class="card-description">${content}</p>
      `;

      card.addEventListener('click', (event) => {
        if (event.altKey || event.ctrlKey || event.metaKey || event.shiftKey) return;
        hideSearch();
      });

      // Add mouseenter event for preview
      async function onMouseEnter(ev) {
        if (!ev.target) return;
        if (currentHover) {
          currentHover.classList.remove('focus');
        }
        const target = ev.target;
        target.classList.add('focus');
        currentHover = target;
        await displayPreview(target);
      }

      card.addEventListener('mouseenter', onMouseEnter);

      return card;
    }

    // Display search results
    async function displayResults(finalResults) {
      removeAllChildren(results);
      
      if (finalResults.length === 0) {
        results.innerHTML = `<a class="result-card no-match">
          <h3>No results.</h3>
          <p>Try another search term?</p>
        </a>`;
        if (preview) {
          removeAllChildren(preview);
        }
      } else {
        results.append(...finalResults.map(resultToHTML));
        
        // Focus on first result and display its preview
        if (enablePreview && preview) {
          const firstChild = results.firstElementChild;
          firstChild.classList.add('focus');
          currentHover = firstChild;
          await displayPreview(firstChild);
        }
      }
    }

    // Handle search input
    async function onType(e) {
      if (!searchLayout || !index) return;

      currentSearchTerm = e.target.value;
      searchLayout.classList.toggle('display-results', currentSearchTerm !== '');

      if (!currentSearchTerm) {
        removeAllChildren(results);
        if (preview) removeAllChildren(preview);
        return;
      }

      // Perform search
      const searchResults = await index.searchAsync({
        query: currentSearchTerm,
        limit: numSearchResults,
        index: ['title', 'content'],
      });

      const getByField = (field) => {
        const filtered = searchResults.filter((x) => x.field === field);
        return filtered.length === 0 ? [] : [...filtered[0].result];
      };

      // Order titles ahead of content
      const allIds = new Set([...getByField('title'), ...getByField('content')]);
      const finalResults = [...allIds].map((id) => formatResult(currentSearchTerm, id));
      await displayResults(finalResults);
    }

    // Keyboard shortcuts
    function shortcutHandler(e) {
      // Cmd/Ctrl+K to open search
      if (e.key === 'k' && (e.ctrlKey || e.metaKey) && !e.shiftKey) {
        e.preventDefault();
        showSearch();
        loadSearchIndex();
      }

      // Escape to close
      if (e.key === 'Escape' || (e.key === 'k' && (e.ctrlKey || e.metaKey) && e.shiftKey)) {
        e.preventDefault();
        hideSearch();
      }

      // Arrow key navigation
      if (container.classList.contains('active')) {
        if (e.key === 'ArrowUp' || (e.shiftKey && e.key === 'Tab')) {
          e.preventDefault();
          if (currentHover) {
            currentHover.classList.remove('focus');
          }
          const prevResult = currentHover
            ? currentHover.previousElementSibling
            : results.lastElementChild;
          if (prevResult) {
            prevResult.classList.add('focus');
            currentHover = prevResult;
            displayPreview(prevResult);
          }
        } else if (e.key === 'ArrowDown' || e.key === 'Tab') {
          e.preventDefault();
          if (currentHover) {
            currentHover.classList.remove('focus');
          }
          const nextResult = currentHover
            ? currentHover.nextElementSibling
            : results.firstElementChild;
          if (nextResult) {
            nextResult.classList.add('focus');
            currentHover = nextResult;
            displayPreview(nextResult);
          }
        } else if (e.key === 'Enter') {
          if (currentHover) {
            e.preventDefault();
            currentHover.click();
          }
        }
      }
    }

    // Event listeners
    searchButton.addEventListener('click', () => {
      showSearch();
      loadSearchIndex();
    });

    searchBar.addEventListener('input', onType);
    document.addEventListener('keydown', shortcutHandler);

    // Close search when clicking outside
    container.addEventListener('click', (e) => {
      if (e.target === container) {
        hideSearch();
      }
    });
  }

  // Initialize search when DOM is ready
  function init() {
    const searchElements = document.querySelectorAll('.search');
    searchElements.forEach((el) => setupSearch(el));
    
    if (searchElements.length > 0) {
      console.log(`[Search] Initialized ${searchElements.length} search element(s)`);
    }
  }

  // Wait for FlexSearch to load
  console.log('[Search] DOM ready, waiting for FlexSearch...');
  const maxAttempts = 100; // 10 seconds (100 * 100ms)
  let attempts = 0;
  const flexSearchCDN = 'https://cdn.jsdelivr.net/npm/flexsearch@0.7.31/dist/flexsearch.bundle.js';

  function waitForFlexSearch() {
    if (typeof FlexSearch !== 'undefined' && FlexSearch.Document) {
      console.log('[Search] FlexSearch is ready');
      init();
    } else if (attempts < maxAttempts) {
      attempts++;
      if (attempts % 10 === 0) {
        console.log(`[Search] Waiting for FlexSearch... (${attempts}/${maxAttempts})`);
      }
      setTimeout(waitForFlexSearch, 100);
    } else {
      console.error(`[Search] FlexSearch failed to load after ${maxAttempts / 10} seconds. Please check the CDN link: ${flexSearchCDN}`);
    }
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      waitForFlexSearch();
    });
  } else {
    waitForFlexSearch();
  }
})();
